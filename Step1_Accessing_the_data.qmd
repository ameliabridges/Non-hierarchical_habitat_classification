---
title: "A guide to developing non-hierarchical habitat classifications using open-source data and software: Accessing the data"
author: "Amelia E.H. Bridges et al."
format: html
---

# An introduction to this document 

[Blurb on method, examples of use]
[How to use this document]

# Prepare your folder structure & working environment

[Blurb on packages]

```{r}
#| message: false
#| results: false
#| output: false
#| warning: false

library(sdmpredictors)
library(raster)
library(tidyverse)
library(MultiscaleDTM)
library(terra)
```

[Blurb on importance of folder structure]

Your working directory (wd) should be the folder you've downloaded from this GitHub repository where the .Rproj file is located. You can check this by running getwd().

```{r}
#| results: hide

getwd()
```

```{r}
wd<-getwd()
```

You'll notice there are other subfolders so for ease, let's create paths to them too.

```{r}
raw_input_layers_folder<-paste0(wd, "/InputLayers/Unprocessed")

clust_input_layers_folder<-paste0(wd, "/InputLayers")

output_layers_folder<-paste0(wd, "/OutputLayers")

results_folder<-paste0(wd, "/Results")
```

```{r}
my_plot_theme <- function(...){

  ggplot2::theme_light()+
    ggplot2::theme(axis.line = ggplot2::element_line(colour = "grey50"),
                   axis.title.y = ggplot2::element_text(face="bold", angle=90),
                   axis.title.x = ggplot2::element_text(face="bold"),
                   panel.border = element_rect(colour = "black", fill=NA, linewidth=1),
                   plot.title = ggplot2::element_text(size=14,hjust=0.5),
                   legend.text.align = 0.5,
                   legend.title.align = 0,
                   axis.title = ggplot2::element_text(size=14,vjust=0.5),
                   axis.text.x = ggplot2::element_text(size = 12,
                                                       colour = "black"),
                   axis.text.y = ggplot2::element_text(colour = "black",
                                                       size = 12),
                   ...)
}
```

# Read in the data

## Topography

In [McQuaid et al. (2023)](https://www.sciencedirect.com/science/article/pii/S0079661123000599?via%3Dihub#s0220), we used three topographic variables to create our 'topography layer' - these were slope, fine-scale bathymetric position index (FBPI) and broad-scale (BBPI). These variables are derivatives of bathymetry (i.e. they can be calculated from bathymetry).

```{r}
bathy<-raster(paste0(raw_input_layers_folder, "/GEBCO2020_Depth_10km_WGS84.tif"))
```

You'll notice that the rasters I'm bringing in are named in similar ways. I use a naming convention that ensures I know the source (the GEBCO 2020 grid), variable (depth), resolution (10km) and projection (WGS84), without having to open the file. When working in R, calling the object (in this case 'bathy') also allows us to quickly look at the details including what coordinate reference system (crs) it's in. 

```{r}
bathy
```

As *per* the above, our bathymetry raster is in WGS84. To calculate the bathymetric derivatives we want, we need our bathymetry in an equal-area projection where all cells on the grid are the same size.

There are hundreds of equal-area projections to choose from but we're going to use Mollweide - [this page](https://desktop.arcgis.com/en/arcmap/latest/map/projections/mollweide.htm) explains it's limitations and advantages nicely. The proj4string for Mollweide is '+proj=moll +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84'.

```{r}
#| warning: false
#| message: false

molproj<-"+proj=moll +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84"
bathy_MOL<-projectRaster(bathy, crs=molproj, res=c(10000,10000))
plot(bathy_MOL, main="Bathymetry (Mollweide)")
```

You can see from the map that this is in the Mollweide projection as opposed to the WGS84 version below.

```{r}
#| warning: false
#| message: false

plot(bathy, main="Bathymetry (WGS84)")
```

Now we have out bathymetry data read in and in the correct projection, we need to calculate slope, FBPI and BBPI and we do this using the [MultiscaleDTM](https://rdrr.io/github/ailich/MultiscaleDTM/) package described in [Ilich et al. (2023)](https://onlinelibrary.wiley.com/doi/full/10.1111/tgis.13067).

### Slope

[Blurb on slope]

```{r}
slo<-SlpAsp(bathy_MOL, w=c(3,3), unit="degrees", method="queen", metrics="slope")
slo
```

This raster is in Mollweide but we want to make our classification in WGS84 - this is because in marine spatial planning, WGS84 is more commonly used. 

```{r}
#| warning: false
#| message: false

wgsproj<-"+proj=longlat +datum=WGS84 +no_defs"
slo<-projectRaster(slo, bathy, crs=wgsproj)

```

R is brilliant for quickly automating tasks, but it's still really important for us to 'eyeball' our data and ensure the input variables look correct. This is where expert opinion and knowing your study area is crucial. 

```{r}
plot(slo, main="Slope")
```

These values and the plot look as one would expect for a global slope map, with large ridge systems identified as well as flat abyssal plains.  

Given the aim of this workshop is to provide skills in developing **regional** habitat classifications, we're going to clip our rasters and work in the Gulf of Guinea. If we plot this clip, we see our slope values for our region of interest. 

```{r}
gog_shp<-terra::vect(paste0(clust_input_layers_folder, "/Gulf_of_Guinea.shp"))
slo<-terra::rast(slo) # we convert into a SpatRaster format for the crop() function
slo<-crop(slo, gog_shp)
```

Note, whilst I made the Gulf of Guinea shapefile, there are plenty of R packages that contain national shapefiles.

```{r}

plot(slo, main="Slope: Gulf of Guinea")
```

Let's save the output.

```{r}
slo<-raster(slo) # we convert into a SpatRaster format for the crop() function
terra::writeRaster(slo, filename=(paste0(raw_input_layers_folder, "/GEBCO2020_GoG_Slo_10km_WGS84.tif")), overwrite=TRUE, format="GTiff")
```

### Broad-scale bathymetric position index (BBPI)

[Blurb on BBPI and radii]

```{r}
specs<-annulus_window(c(1,10), "cell")
bbpi<-MultiscaleDTM::BPI(bathy_MOL, w = specs, unit = "cell", na.rm = TRUE)
bbpi
```

The values look sensible. 

```{r}
#| warning: false
#| message: false

bbpi<-projectRaster(bbpi, bathy, crs=wgsproj)
bbpi<-terra::rast(bbpi) # we convert into a SpatRaster format for the crop() function
bbpi<-crop(bbpi, gog_shp)

```

```{r}
#| warning: false
#| message: false

plot(bbpi, main="BBPI: Gulf of Guinea")
```

And so does the plot so we'll save the layer. 

```{r}
bbpi<-raster(bbpi) # 
terra::writeRaster(bbpi, filename=(paste0(raw_input_layers_folder, "/GEBCO2020_GoG_BBPI_10km_WGS84.tif")), overwrite=TRUE, format="GTiff")
```

### Fine-scale bathymetric position index (FBPI)

[Blurb on FBPI and why we chose these radii]

```{r}
specs<-annulus_window(c(1,2), "cell")
fbpi<-MultiscaleDTM::BPI(bathy_MOL, w = specs, unit = "cell", na.rm = TRUE)
fbpi
```

The values look sensible. 

```{r}
#| warning: false
#| message: false

fbpi<-projectRaster(fbpi, bathy, crs=wgsproj)
fbpi<-terra::rast(fbpi) # we convert into a SpatRaster format for the crop() function
fbpi<-crop(fbpi, gog_shp)

```

```{r}
#| warning: false
#| message: false

plot(fbpi, main="FBPI: Gulf of Guinea")
```

And so does the plot so we'll save the layer. 

```{r}
fbpi<-raster(fbpi) # 
terra::writeRaster(fbpi, filename=(paste0(raw_input_layers_folder, "/GEBCO2020_GoG_FBPI_10km_WGS84.tif")), overwrite=TRUE, format="GTiff")
```

## Productivity

The productivity (particulate organic carbon (POC) flux to depth) layer we're using comes from the NEMO-MEDUSA model. Authors have uploaded the netCDF version on Zenodo, [here](https://zenodo.org/record/6513616#.Yn6TGx1BzIU). However for ease, the TIFF version is in the 'InputLayers' folder of this repo. Let's read it in. 

```{r}
#| warning: false
#| message: false

prod<-raster(paste0(raw_input_layers_folder, "/Yool_POC_10km_WGS84.tif"))
plot(prod, main="POC flux to depth")
```

Again, here you can see that (as expected) continental shelves have higher productivity and you can see the slight increases in productivity in temperate latitudes.

```{r}
prod<-terra::rast(prod) # we convert into a SpatRaster format for the crop() function
prod<-crop(prod, gog_shp)
plot(prod, main="POC flux to depth: Gulf of Guinea")
```


```{r}
prod<-raster(prod)
terra::writeRaster(prod, filename=(paste0(raw_input_layers_folder, "/Yool_GoG_POC_10km_WGS84.tif")), overwrite=TRUE, format="GTiff")
```


## Water mass structure

[Blurb on data repositories, example links etc.]

```{r}
sdm_datasets<-sdmpredictors::list_datasets(terrestrial = FALSE, marine = TRUE)

layers<-sdmpredictors::list_layers(sdm_datasets)%>%
  filter(str_detect(layer_url, 'Present.Benthic.Mean.Depth'))%>%
  filter(primary_spatial_resolution=="0.25 arcdegree")%>%
  filter(version==22)
```

These are the 66 layers available from Bio-ORACLE (version 2.2) for which the values refer to present benthic conditions taken at the mean depth of each cell at a 0.25 arc degree resolution. 

We want to download the latest version (BO22) of mean temperature and salinity (tempmean/salinitymean) for the mean bottom depth (bdmean).

### Temperature

```{r}
#| warning: false
#| message: false

temp<-load_layers("BO22_tempmean_bdmean", equalarea=FALSE)
temp
```

```{r}
#| warning: false
#| message: false

plot(temp, main="Bottom Temperature")
```

```{r}
temp<-terra::rast(temp) # we convert into a SpatRaster format for the crop() function
temp<-crop(temp, gog_shp)
plot(temp, main="Bottom Temperature: Gulf of Guinea")
```

### Salinity

```{r}
#| warning: false
#| message: false

sal<-load_layers("BO22_salinitymean_bdmean", equalarea = FALSE)
sal

```

```{r}
#| warning: false
#| message: false

plot(sal, main="Bottom Salinity")
```

```{r}
sal<-terra::rast(sal) # we convert into a SpatRaster format for the crop() function
sal<-crop(sal, gog_shp)
plot(sal, main="Bottom Salinity: Gulf of Guinea")
```

## Biogeography

[PUT IN TEXT FROM PAPER]

The final layer we need is biogeography to differentiate between two 'unconnected' areas with similar conditions (e.g. the Arctic and the Antarctic). 

For most workshop attendees, the aim is to develop regional habitat classifications and therefore biogeography is not necessarily required. However, if your region of interest straddles >1 biogeographic region, you will want to create a biogeography input layer. 

There are plenty of published biogeographies at both regional and global scales. Most of these are heaily influenced by water mass structure. However, their water mass structure boundaries will not align exactly with yours. Therefore, if you import a published biography directly onto your classification, you will end up with high numbers of habitat classes around the 'joins' which might throw off your analysis. 

To get around this in the McQuaid et al. (2023) paper, we followed the water mass boundaries from our clustered WMS input layer. 
In the McQuaid et al. (2023) paper, 




